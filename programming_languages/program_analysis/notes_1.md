# 软件分析 Lecture Note 1

## 背景：程序语言的相关研究

程序语言是一个比较大的领域，包含很多分支：

- 理论方面：包含类型论、语义和相关逻辑（如 Separation Logic，Operational Semantics 这些）等。可以说是偏数学化。
- 环境方面：包含编译器理论、运行环境等。
- 应用方面：包含*程序分析*、程序验证和程序合成（Program synthesis）等。

这里讨论的主要是程序分析，并且是**静态程序分析（Static Program Analysis）**，或者简称**静态分析（Static Analysis）**。

## 静态、动态？

为什么说是静态？这里静态是指程序还没有运行时的状态。静态分析技术就是用来针对某个程序 $P$，在实际运行 $P$ 之前了解 $P$ 的行为（behavior）以及 $P$ 的一些性质。这里的行为直观意义上指的是程序会做什么。

相比较而言，动态分析（Dynamic Analysis）会分析程序运行时的一些信息。

## 完美的分析？

一个正则语言如果是递归可枚举的（Recursive enumerable），那么它可以被图灵机识别。现有的程序语言都是递归可枚举的。

如果某个关于正则语言的性质对于所有正则语言都成立或者都不成立，那么这个性质是平凡的（Trivial）。显然，我们希望分析的性质应当是非平凡的（Non-trivial）。

我们希望分析足够靠谱，即对于一个非平凡性质和一个程序，能够对于该性质是否在该程序上成立给出**完全正确**的回答。可惜，由可计算性理论中的莱斯定理（Rice's theorem），这是做不到的。

换言之，完美的分析是不存在的。这里的完美包含可靠（Sound）和完备（Complete）两个方面。

- 如果程序包含的错误分析都给出了，那么分析是可靠的。
- 如果分析给出的真的全都是错误，那么分析是完备的。

可以看出，就分析给出的错误的个数而言，可靠 > 可靠且完备 > 完备。

## 有用的分析！

分析不完美不要紧，有用也行。有用的分析势必需要妥协，即牺牲一定的可靠或者完备性，以向中间地带——可靠且完备靠拢。

- 牺牲一定的可靠性可能导致**漏报**错误，对应 False-negative。
- 牺牲一定的完备性可能导致**误报**错误，对应 False-positive。

一般的分析都牺牲了完备性，即做的是可靠但不那么精确的分析。原因在于很多应用场景下（如编译器优化、程序验证、bug 检测）可靠性都十分重要。

## 静态分析的应用

静态分析作为程序语言应用方面的一个重要组成部分得到了广泛的应用，包括：

- 保证程序可靠。如防止内存泄露、空指针解引用等。
- 保证程序安全。如阻止注入攻击（injection attack）等。
- 辅助编译优化。如常量替换等。
- 帮助理解程序。如在 IDE 中查看函数的调用层次等。

